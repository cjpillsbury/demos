{"version":3,"file":"spanning-css-polyfill.js","sources":["../src/constants.js","../src/utils/css-text-processors.js","../src/index.js","../src/utils/misc.js","../src/utils/device-geometry.js"],"sourcesContent":["export const SPANNING_MF_KEY = \"spanning\";\nexport const SPANNING_MF_VAL_HOR = \"single-fold-horizontal\";\nexport const SPANNING_MF_VAL_VER = \"single-fold-vertical\";\nexport const SPANNING_MF_VAL_NONE = \"none\";\n\nexport const CSS_ENV_FOLD_TOP = \"fold-top\";\nexport const CSS_ENV_FOLD_LEFT = \"fold-left\";\nexport const CSS_ENV_FOLD_HEIGHT = \"fold-height\";\nexport const CSS_ENV_FOLD_WIDTH = \"fold-width\";\n\nexport const POLYFILL_NAMESPACE = \"__foldables_env_vars__\";\n","import {\n  SPANNING_MF_KEY,\n  SPANNING_MF_VAL_HOR,\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_NONE\n} from \"../constants.js\";\n\nconst SPANNING_MEDIA_BLOCK_REGEXP_STR = `(@media.*?\\\\b${SPANNING_MF_KEY}\\\\b[^{]+)\\\\{([\\\\s\\\\S]+?\\\\})\\\\s*\\\\}`;\n\nconst MEDIA_FEATURES_REGEXP = /\\((.*?)\\)/gi;\n\nconst MEDIA_TYPES_REGEXP = /@media[^\\(]+/gi;\n\nconst cssEnvVariableRegExpMaker = variable => {\n  return new RegExp(`env\\\\(\\\\s*${variable}\\\\s*\\\\)`, \"gi\");\n};\n\n/**\n * Finds and returns an array of `@media` blocks with containing spanning media feature\n *\n * @param {string} cssText\n *\n * @returns {string[]}\n */\nexport function _processSpanningMediaBlock(cssText) {\n  const regex = new RegExp(SPANNING_MEDIA_BLOCK_REGEXP_STR, \"gi\");\n\n  // matchAll is not yet supported in Safari, but shipped in Edge, Chrome and FF\n  // Accoding to Babel docs: https://babeljs.io/docs/en/babel-preset-env#shippedproposals\n  // setting {useBuiltIns: \"usage\"} will use the browser shipped version rather than\n  // the transpiled version.\n  const spanningMediaBlocks = Array.from(cssText.matchAll(regex));\n\n  return spanningMediaBlocks;\n}\n\n/**\n * Replaces spanning `@media` blocks containing `spanning` feature\n * and returns a new stylesheet string\n *\n * @param {String} originalSheetStr\n * @param {String} replaceWith\n *\n * @returns {String}\n */\nexport function replaceSpanningMediaBlocks(originalSheetStr, replaceWith) {\n  return originalSheetStr.replace(\n    new RegExp(SPANNING_MEDIA_BLOCK_REGEXP_STR, \"gi\"),\n    replaceWith\n  );\n}\n\n/**\n * Replaces a word in a string and returns a new string\n *\n * @param {String} originalSheetStr\n * @param {String} cssEnvVariable\n * @param {String} replaceWith\n *\n * @returns {String}\n */\nexport function replaceCSSEnvVariables(\n  originalSheetStr,\n  cssEnvVariable,\n  replaceWith\n) {\n  return originalSheetStr.replace(\n    cssEnvVariableRegExpMaker(cssEnvVariable),\n    replaceWith\n  );\n}\n\n/**\n * Returns an array of media features found a string sucb as\n * `(min-width: ..)`, `(orientation:..)` etc.\n *\n * @param {String[]} mediaQueryStr\n *\n * @returns {String[]}\n */\nexport function _getMediaFeatures(mediaQueryStr) {\n  return mediaQueryStr.match(MEDIA_FEATURES_REGEXP) || [];\n}\n\n/**\n * Returns an array containing `@media` and following media types such\n * as screen, all, print, etc. up until the first media feature parenthesis\n *\n * @param {*} mediaQueryStr\n *\n * @returns {String[]}\n */\nexport function _getMediaTypes(mediaQueryStr) {\n  return mediaQueryStr.match(MEDIA_TYPES_REGEXP) || [];\n}\n\n/**\n * Finds all spanning media queries in CSS text and returns an object of all media\n * queries, grouped by type\n *\n * @param {*} cssText\n */\nexport function getSpanningCSSText(cssText) {\n  const spanningMediaBlocks = _processSpanningMediaBlock(cssText);\n\n  const result = {\n    [SPANNING_MF_VAL_HOR]: \"\",\n    [SPANNING_MF_VAL_VER]: \"\",\n    [SPANNING_MF_VAL_NONE]: \"\"\n  };\n\n  spanningMediaBlocks.forEach(block => {\n    const definition = block[1];\n    const content = block[2];\n\n    //TODO: this is bad.\n    let spanningValue = SPANNING_MF_VAL_NONE;\n    if (definition.indexOf(SPANNING_MF_VAL_HOR) > -1) {\n      spanningValue = SPANNING_MF_VAL_HOR;\n    }\n    if (definition.indexOf(SPANNING_MF_VAL_VER) > -1) {\n      spanningValue = SPANNING_MF_VAL_VER;\n    }\n\n    const mediaTypes = _getMediaTypes(definition);\n    let mediaFeatures = _getMediaFeatures(definition);\n\n    mediaFeatures = mediaFeatures\n      .filter(f => !f.includes(SPANNING_MF_KEY))\n      .join(\" and \");\n\n    result[spanningValue] += `\n      ${mediaTypes} ${mediaFeatures} {\n        ${content}\n      }`;\n  });\n\n  return result;\n}\n","import {\n  POLYFILL_NAMESPACE,\n  SPANNING_MF_VAL_NONE,\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_HOR\n} from \"./constants.js\";\n\nimport {\n  getSpanningCSSText,\n  replaceSpanningMediaBlocks,\n  replaceCSSEnvVariables\n} from \"./utils/css-text-processors.js\";\n\nimport { getDeviceFoldRects } from \"./utils/device-geometry.js\";\n\nimport { fetchCSSText, debounce, createElement } from \"./utils/misc.js\";\n\nif (typeof window[POLYFILL_NAMESPACE] === typeof(undefined)) {\n  // polyfill configuration related variables\n  const spanning =\n    sessionStorage.getItem(`${POLYFILL_NAMESPACE}-spanning`) ||\n    SPANNING_MF_VAL_NONE;\n  const foldSize =\n    +sessionStorage.getItem(`${POLYFILL_NAMESPACE}-foldSize`) || 0;\n  const browserShellSize =\n    +sessionStorage.getItem(`${POLYFILL_NAMESPACE}-browserShellSize`) || 0;\n  // global configs, accessible via the window object\n  Object.defineProperty(window, POLYFILL_NAMESPACE, {\n    value: {\n      spanning,\n      foldSize,\n      browserShellSize,\n      update: update,\n      onupdate: [insertSpanningStyles]\n    }\n  });\n\n  // Web-based emulator runs this polyfill in an iframe, we need to\n  // communicate emulator state changes to the site.\n  // Should only be registered once (in CSS or JS polyfill not both)\n  window.addEventListener(\"message\", evt => {\n    const action = evt.data.action || \"\";\n    const value = evt.data.value || {};\n    if (action === \"update\") {\n      window[POLYFILL_NAMESPACE].update(value);\n    }\n  });\n} else {\n  window[POLYFILL_NAMESPACE].onupdate.push(insertSpanningStyles);\n}\n\nconst cssElements = Array.from(\n  document.querySelectorAll('link[rel=\"stylesheet\"], style')\n);\n\n// original page CSS\n//let cssText = \"\";\n\n/**\n * modified page CSS text: env(fold-*) variables replaced (spanning: *) media query replaced\n * grouped in this object as:\n *\n * -- single-fold-vertical: CSS found in the media feature (spanning: single-fold-vertical)\n * -- single-fold-horizontal: CSS found in the media feature (spanning: single-fold-horizontal)\n * -- none: CSS found in the media feature (spanning: none)\n */\nconst spanning = {\n  [SPANNING_MF_VAL_HOR]: \"\",\n  [SPANNING_MF_VAL_VER]: \"\",\n  [SPANNING_MF_VAL_NONE]: \"\"\n};\n\nfetchCSSText(cssElements).then(sheetsTextContentArray => {\n  const styleFragment = new DocumentFragment();\n  sheetsTextContentArray.forEach((sheet, i) => {\n    // all other css excluding spanning media blocks\n    const noSpanningCSS = replaceSpanningMediaBlocks(sheet, \"\");\n    const spanningCSS = getSpanningCSSText(sheet);\n\n    const sheetOrigin = cssElements[i].href || \"inline\";\n\n    Object.keys(spanningCSS).forEach(k => {\n      if (typeof spanning[k] !== typeof(undefined)) {\n        spanning[k] += `\n          /* origin:  ${sheetOrigin} */\n          ${spanningCSS[k]}`;\n      }\n    });\n\n    styleFragment.appendChild(\n      createElement(\"style\", { \"data-css-origin\": sheetOrigin }, noSpanningCSS)\n    );\n  });\n\n  // Spanning media blocks grouped by spanning type (single-fold-horizontal, vertical or none)\n  // let spanningCSSText = getSpanningCSSText(cssText);\n  // editedCSSText = Object.assign(editedCSSText, spanningCSSText);\n\n  cssElements.forEach(el => el.parentElement.removeChild(el));\n\n  document.head.appendChild(styleFragment);\n\n  // insert spanning media query stylesheet\n  insertSpanningStyles();\n\n  window.addEventListener(\"resize\", debounce(insertSpanningStyles, 150));\n});\n\n// looks at configs and appends the correct `spanning` styles\nfunction insertSpanningStyles() {\n  Array.from(document.querySelectorAll(`.${POLYFILL_NAMESPACE}`)).forEach(el =>\n    el.parentElement.removeChild(el)\n  );\n  let configs = window[POLYFILL_NAMESPACE];\n\n  if (configs.spanning === SPANNING_MF_VAL_NONE) return;\n\n  let spanningCSSText = spanning[configs.spanning];\n  let rects = getDeviceFoldRects(configs);\n\n  Object.keys(rects).forEach(r => {\n    spanningCSSText = replaceCSSEnvVariables(\n      spanningCSSText,\n      r,\n      `${rects[r]}px`\n    );\n  });\n\n  let polyfilledStyles = document.createElement(\"style\");\n  polyfilledStyles.className = POLYFILL_NAMESPACE;\n  polyfilledStyles.textContent = spanningCSSText;\n  document.head.appendChild(polyfilledStyles);\n}\n\nconst VALID_CONFIG_PROPS = new Set([\n  \"foldSize\",\n  \"browserShellSize\",\n  \"spanning\"\n]);\n\nfunction update(newConfings) {\n  Object.keys(newConfings).forEach(k => {\n    if (VALID_CONFIG_PROPS.has(k)) {\n      window[POLYFILL_NAMESPACE][k] = newConfings[k];\n      sessionStorage.setItem(\n        `${POLYFILL_NAMESPACE}-${k}`,\n        window[POLYFILL_NAMESPACE][k]\n      );\n    }\n  });\n\n  window[POLYFILL_NAMESPACE].onupdate.forEach(fn => fn());\n}\n","/**\n * Returns a promise, once resolved it contains an array\n * of CSS text retrieved from <link> URLs and <style> DOM elements\n *\n * @param {array} elements JavaScript array (not NodeList)\n *\n * @return {Promise<string[]>}\n */\nexport function fetchCSSText(elements) {\n  return Promise.all(\n    elements.map(element => {\n      const href = element.href;\n      if (href) {\n        return fetch(href).then(r => r.text());\n      }\n      return element.textContent;\n    })\n  );\n}\n\n/**\n * Returns a function that won't call `fn` if it was invoked at a\n * faster interval than `wait`\n *\n * @param {Function} fn\n * @param {Number} wait - milliseconds\n */\nexport function debounce(fn, wait) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn.apply(this, arguments), wait);\n  };\n}\n\n/**\n *\n * @param {String} name\n * @param {Object} attributes\n * @param {String} content\n *\n * @return {DOM Node}\n */\nexport function createElement(name, attributes, content) {\n  const el = document.createElement(name);\n  Object.keys(attributes).forEach(k => {\n    el.setAttribute(k, attributes[k])\n  })\n  if (typeof content !== typeof(undefined)) {\n    el.textContent = content;\n  }\n  return el;\n}","import {\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_HOR,\n  CSS_ENV_FOLD_TOP,\n  CSS_ENV_FOLD_LEFT,\n  CSS_ENV_FOLD_HEIGHT,\n  CSS_ENV_FOLD_WIDTH\n} from \"../constants.js\";\n\n/**\n * Returns the device fold (hinge) geometry\n *\n * @param {Object} configs\n * @returns {Object}\n */\nexport function getDeviceFoldRects(configs) {\n  let left = 0,\n    top = 0,\n    width = 0,\n    height = 0;\n  if (configs.spanning === SPANNING_MF_VAL_VER) {\n    width = configs.foldSize;\n    height = window.innerHeight;\n    left = window.innerWidth / 2 - configs.foldSize / 2;\n  }\n  if (configs.spanning === SPANNING_MF_VAL_HOR) {\n    width = window.innerWidth;\n    height = configs.foldSize;\n    top =\n      ((window.innerHeight - configs.browserShellSize) / 2) - (configs.foldSize / 2);\n  }\n  return {\n    [CSS_ENV_FOLD_TOP]: top,\n    [CSS_ENV_FOLD_LEFT]: left,\n    [CSS_ENV_FOLD_HEIGHT]: height,\n    [CSS_ENV_FOLD_WIDTH]: width\n  };\n}\n"],"names":["const","SPANNING_MF_VAL_HOR","SPANNING_MF_VAL_VER","SPANNING_MF_VAL_NONE","CSS_ENV_FOLD_TOP","CSS_ENV_FOLD_LEFT","CSS_ENV_FOLD_HEIGHT","CSS_ENV_FOLD_WIDTH","POLYFILL_NAMESPACE","MEDIA_FEATURES_REGEXP","MEDIA_TYPES_REGEXP","cssEnvVariableRegExpMaker","variable","RegExp","window","spanning","sessionStorage","getItem","foldSize","browserShellSize","Object","defineProperty","value","update","newConfings","keys","forEach","k","VALID_CONFIG_PROPS","has","setItem","onupdate","fn","insertSpanningStyles","addEventListener","evt","data","action","push","elements","cssElements","Array","from","document","querySelectorAll","el","parentElement","removeChild","configs","spanningCSSText","rects","left","top","width","height","innerHeight","innerWidth","getDeviceFoldRects","r","replaceWith","replace","polyfilledStyles","createElement","className","textContent","head","appendChild","Promise","all","map","element","href","fetch","then","text","sheetsTextContentArray","timeout","styleFragment","DocumentFragment","sheet","i","attributes","content","spanningMediaBlocks","result","noSpanningCSS","spanningCSS","cssText","regex","matchAll","_processSpanningMediaBlock","block","definition","spanningValue","indexOf","mediaTypes","match","mediaFeatures","filter","f","includes","join","sheetOrigin","setAttribute","clearTimeout","setTimeout","apply","this","arguments","Set"],"mappings":"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"}