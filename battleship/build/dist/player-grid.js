function w(a,c,b){return c in a?Object.defineProperty(a,c,{value:b,enumerable:!0,configurable:!0,writable:!0}):a[c]=b,a}function q(a,c,b){return typeof Reflect!=="undefined"&&Reflect.get?q=Reflect.get:q=function d(e,h,k){var i=z(e,h);if(!i)return;var l=Object.getOwnPropertyDescriptor(i,h);return l.get?l.get.call(k):l.value},q(a,c,b||a)}function z(a,c){for(;!Object.prototype.hasOwnProperty.call(a,c);){a=r(a);if(a===null)break}return a}function r(a){return r=Object.setPrototypeOf?Object.getPrototypeOf:function c(b){return b.__proto__||Object.getPrototypeOf(b)},r(a)}import{html as x,css as A}from"../web_modules/lit-element.js";import{GameGrid as B}from"./game-grid.js";import*as f from"./ship.js";export const GridDirection={Top:"Top",Bottom:"Bottom",Left:"Left",Right:"Right"};export class PlayerGrid extends B{firstUpdated(){super.firstUpdated(),this.generateRandomGrid(),this._boatsToSink=[f.ShipType.Carrier,f.ShipType.Battleship,f.ShipType.Submarine,f.ShipType.Destroyer,f.ShipType.Rescue]}constructor(){super();w(this,"_pendingSanks",[]),w(this,"_boatsToSink",[]),this._previousShot={x:0,y:0}}restart(){super.restart(),this._previousShot={x:0,y:0},this._pendingSanks=[],this._boatsToSink=[f.ShipType.Carrier,f.ShipType.Battleship,f.ShipType.Submarine,f.ShipType.Destroyer,f.ShipType.Rescue]}isCellAPreviouslyMissedShot(a){return a.shot&&a.type===void 0}isCellABoatPreviouslyShot(a){return a.shot&&a.type!=void 0&&a.type===this.grid[this._previousShot.x][this._previousShot.y].type}biggestBoatLeft(){return f.getShipSize(this._boatsToSink[0])}smallestBoatLeft(){return f.getShipSize(this._boatsToSink[this._boatsToSink.length-1])}boatsLeftFitAround(a,c){let b=this.biggestBoatLeft();const d={x:a,y:c},e=this.walkGridAndCountEmptySpaces(GridDirection.Left,d,b-1,0),h=this.walkGridAndCountEmptySpaces(GridDirection.Right,d,b-1,0),k=this.walkGridAndCountEmptySpaces(GridDirection.Top,d,b-1,0),i=this.walkGridAndCountEmptySpaces(GridDirection.Bottom,d,b-1,0);return e+1===b||h+1===b||k+1===b||i+1===b||e+h+1>=b||k+i+1>=b?!0:!1}walkGridAndCountEmptySpaces(a,c,b,d){if(this.isCellAtTheEge(a,c))return d;const e=this.getNeighborCell(a,c);return this.grid[e.x][e.y].shot===!0?d:(d++,d===b?d:this.walkGridAndCountEmptySpaces(a,e,b,d))}isCellAtTheEge(a,c){return a===GridDirection.Left&&c.y-1===0||a===GridDirection.Right&&c.y+1===11||a===GridDirection.Top&&c.x-1===0||a===GridDirection.Bottom&&c.x+1===11}getNeighborCell(a,c){let b=c;switch(a){case GridDirection.Left:b={x:c.x,y:Math.max(c.y-1,1)};break;case GridDirection.Right:b={x:c.x,y:Math.min(c.y+1,10)};break;case GridDirection.Top:b={x:Math.max(c.x-1,1),y:c.y};break;case GridDirection.Bottom:b={x:Math.min(c.x+1,10),y:c.y};break;default:console.error("wrong direction");return}return b}walkGridToFindEmptyCell(a,c){if(this.isCellAtTheEge(a,c))return null;const b=this.getNeighborCell(a,c);return this.isCellAPreviouslyMissedShot(this.grid[b.x][b.y])?null:this.isCellABoatPreviouslyShot(this.grid[b.x][b.y])?this.walkGridToFindEmptyCell(a,b):this.grid[b.x][b.y].shot===!0?null:b}walkGridToFindCandidateToShoot(a,c,b,d){if(this.isCellAtTheEge(a,c))return d;const e=this.getNeighborCell(a,c);return this.isCellAPreviouslyMissedShot(this.grid[e.x][e.y])?d:this.isCellABoatPreviouslyShot(this.grid[e.x][e.y])?this.walkGridToFindCandidateToShoot(a,e,b,++d):this.grid[e.x][e.y].shot===!0?d:(d++,d>=b?d:this.walkGridToFindCandidateToShoot(a,e,b,d))}isBoatHorizontal(a){let c=null;if(!this.isCellAtTheEge(GridDirection.Left,a)){let b=this.getNeighborCell(GridDirection.Left,a);this.isCellABoatPreviouslyShot(this.grid[b.x][b.y])&&(c=!0)}if(!this.isCellAtTheEge(GridDirection.Right,a)){let b=this.getNeighborCell(GridDirection.Right,a);this.isCellABoatPreviouslyShot(this.grid[b.x][b.y])&&(c=!0)}return c}isBoatVertical(a){let c=null;if(!this.isCellAtTheEge(GridDirection.Top,a)){let b=this.getNeighborCell(GridDirection.Top,a);this.isCellABoatPreviouslyShot(this.grid[b.x][b.y])&&(c=!0)}if(!this.isCellAtTheEge(GridDirection.Bottom,a)){let b=this.getNeighborCell(GridDirection.Bottom,a);this.isCellABoatPreviouslyShot(this.grid[b.x][b.y])&&(c=!0)}return c}enemyShoot(){if(this.isGameOver())return;let a,c;if(this._previousShot.x!=0&&this._previousShot.y!=0){let b,d,e,h,k=!1,i=!1,l=!1,p=!1,m,g=this.smallestBoatLeft();const s=this.walkGridToFindCandidateToShoot(GridDirection.Left,this._previousShot,g-1,0),t=this.walkGridToFindCandidateToShoot(GridDirection.Right,this._previousShot,g-1,0),u=this.walkGridToFindCandidateToShoot(GridDirection.Top,this._previousShot,g-1,0),v=this.walkGridToFindCandidateToShoot(GridDirection.Bottom,this._previousShot,g-1,0);let n=this.isBoatVertical(this._previousShot),o=this.isBoatHorizontal(this._previousShot);s>0&&(o===null||o)&&(s+1===g||t+s+1>=g)&&(b=this.walkGridToFindEmptyCell(GridDirection.Left,this._previousShot),b&&(k=!0)),t>0&&(o===null||o)&&(t+1===g||t+s+1>=g)&&(d=this.walkGridToFindEmptyCell(GridDirection.Right,this._previousShot),d&&(i=!0)),u>0&&(n===null||n)&&(u+1===g||u+v+1>=g)&&(e=this.walkGridToFindEmptyCell(GridDirection.Top,this._previousShot),e&&(l=!0)),v>0&&(n===null||n)&&(v+1===g||u+v+1>=g)&&(h=this.walkGridToFindEmptyCell(GridDirection.Bottom,this._previousShot),h&&(p=!0)),n===null&&o===null?m=Math.random()>=.5:o?m=!1:n&&(m=!0),m&&!p&&!l&&(m=!1),!m&&!k&&!i&&(m=!0);if(m&&(l||p)){if(l&&p){const y=Math.random()>=.5;y?a=e.x:a=h.x}else l?a=e.x:p&&(a=h.x);c=this._previousShot.y}else{if(k&&i){const y=Math.random()>=.5;y?c=b.y:c=d.y}else i?c=d.y:k&&(c=b.y);a=this._previousShot.x}}else for(a=this.getRandomCoordinate(),c=this.getRandomCoordinate();this.grid[a][c].shot===!0||this.grid[a][c].shot===!1&&!this.boatsLeftFitAround(a,c);)a=this.getRandomCoordinate(),c=this.getRandomCoordinate();if(this.isShip(this.grid[a][c])){const b=this.shadowRoot.querySelector("#"+this.grid[a][c].type);b.enemyShootAt(a,c),this.grid[a][c].shot=!0,this.grid[a][c].type!=this._previousShot.type&&this._previousShot.type!=void 0&&this._pendingSanks.push(Object.create(this._previousShot)),this._previousShot={x:a,y:c,type:b.type},b.destroyed&&(this._pendingSanks.length>0?this._previousShot=this._pendingSanks.pop():this._previousShot={x:0,y:0}),setTimeout(()=>this.enemyShoot(),2e3);return}this.grid[a][c].shot=!0,this.updateGrid(),this.playerPlayed(a,c)}shipDestroyed(a){this._boatsToSink=this._boatsToSink.filter(c=>c!=a.detail.type),this.playerSankShip(a.detail.type)}shipHit(a){this.playerHitShip(a.detail.type)}render(){return x`
      <div class="title">Your fleet</div>
      <div class="grid">
          ${this.grid.map((a,c)=>a.map((b,d)=>{if(this.isShip(this.grid[c][d])){if(!this.isShipPlaced(b.type))return this._shipPlaced.push(b.type),x`
                      <ship-element id="${b.type}" x="${b.x}" y="${b.y}"
                        type="${b.type}" orientation="${b.orientation}" @ship-hit="${this.shipHit}"
                        @ship-destroyed="${this.shipDestroyed}">
                      </ship-element>`}else return x`<empty-cell ?hit="${b.shot}">${b.text}</empty-cell>`}))}
      </div>
    `}}w(PlayerGrid,"styles",[q(r(PlayerGrid),"styles",PlayerGrid),A`
    :host {
      pointer-events:none;
    }
  `]),customElements.define("player-grid",PlayerGrid);
